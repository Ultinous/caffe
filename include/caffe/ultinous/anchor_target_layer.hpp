#pragma once

#include <vector>

#include "caffe/util/anchors.hpp"
#include "caffe/blob.hpp"
#include "caffe/layer.hpp"
#include "caffe/proto/caffe.pb.h"

namespace caffe {

  namespace ultinous {

/**
 * @brief Provides data to the Net generated by a Filler.
 *
 * TODO(dox): thorough documentation for Forward and proto params.
 */
    struct Offset
    {
      explicit Offset(std::vector<int> v)
      {
        CHECK(v.size()<=4);
        //CHECK(std::find_if(v.begin(),v.end(),[](const int i){return i<=0;}) == v.end());
        v.resize(4,1);
        dN = v[1]*v[2]*v[3];
        dC = v[2]*v[3];
        dH = v[3];
        count = v[0]*dN;
      }
      int dN;
      int dC;
      int dH;
      int count;
      int operator()(int n=0, int c=0, int h=0, int w=0)
      {
        return n * dN + c * dC + h * dH + w;
      }
    };

    template<typename Dtype>
    class AnchorTargetLayer : public Layer<Dtype> {

    protected:
      typedef std::vector<Dtype> Anchor;
      typedef std::vector<Anchor> Boxes;
      typedef float Overlap;
      typedef std::vector<std::vector<Overlap> > Overlaps;

    public:
      explicit AnchorTargetLayer(const LayerParameter &param)
          : Layer<Dtype>(param), anchorTargetParam_(this->layer_param_.anchor_target_param()) {}

      virtual void LayerSetUp(const vector<Blob<Dtype> *> &bottom,
                              const vector<Blob<Dtype> *> &top);

      virtual void Reshape(const vector<Blob<Dtype> *> &bottom,
                           const vector<Blob<Dtype> *> &top) {}

      virtual inline const char *type() const { return "AnchorTarget"; }

      virtual inline int ExactNumBottomBlobs() const { return 4; }

      virtual inline int MinTopBlobs() const { return 4; }

    protected:
      virtual void Forward_cpu(const vector<Blob<Dtype> *> &bottom,
                               const vector<Blob<Dtype> *> &top);

      virtual void Backward_cpu(const vector<Blob<Dtype> *> &top,
                                const vector<bool> &propagate_down, const vector<Blob<Dtype> *> &bottom) {}

      Overlaps bbox_overlaps(Boxes &boxes, Boxes &query_boxes);

      uint32_t hardNegativeMining(uint32_t num_bg,
                                  Offset &bottom_scores_offset, Dtype const *scores,
                                  Offset &top_labels_offset, Dtype *labels,
                                  uint32_t width, uint32_t height, int batch_index);

      uint32_t randomMining(int comparisonValue, int RPN_BATCHSIZE, uint32_t num,
                            Offset &top_labels, Dtype *labels,
                            uint32_t width, uint32_t height, int batch_index);

      std::vector<Anchor> base_anchors_;

      int feat_stride_;
      int allowed_border_;

      AnchorTargetParameter const &anchorTargetParam_;
      string folderName_;
    };

  }  // namespace ultinous

}  // namespace caffe

